---
import ProjectCard from "./ProjectCard.astro";

interface Project {
  slug?: string;
  title: string;
  summary: string;
  image: string;
  tags?: string[];
}
const { items = [] } = Astro.props as { items: Project[] };

const toSlug = (s: string) =>
  s.toLowerCase().trim().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "");
---
<div class="showcase" data-showcase>
  <!-- Prev / Next -->
  <button class="nav prev btn-icon" aria-label="Previous project" data-prev>
    <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/></svg>
  </button>
  <button class="nav next btn-icon" aria-label="Next project" data-next>
    <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M9 6l6 6-6 6" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/></svg>
  </button>

  <!-- Rail -->
  <div
    id="proj-rail"
    class="rail"
    tabindex="0"
    role="listbox"
    aria-label="Projects"
    aria-orientation="horizontal"
  >
    {items.map((p, i) => (
      <div
        class={"slide snap-center" + (i === 0 ? " is-active" : "")}
        role="option"
        aria-selected={i === 0 ? "true" : "false"}
        data-i={i}
      >
        <ProjectCard
          slug={p.slug ?? toSlug(p.title)}
          title={p.title}
          summary={p.summary}
          image={p.image}
          tags={p.tags ?? []}
          maxTags={4}
        />
      </div>
    ))}
  </div>

  <!-- Dots -->
  <div class="dots" aria-hidden="false">
    {items.map((_, i) => (
      <button class={"dot" + (i === 0 ? " is-active" : "")} data-index={i} aria-label={`Go to slide ${i + 1}`}></button>
    ))}
  </div>

  <!-- SR-only live region for slide changes -->
  <p class="sr-only" aria-live="polite" id="sr-status">Slide 1 of {items.length}</p>
</div>

<style>
  .showcase { position: relative; }
  .rail {
    display: grid;
    grid-auto-flow: column;
    grid-auto-columns: 86%;
    gap: 1.25rem;
    overflow-x: auto;
    padding-block: .25rem;
    scroll-snap-type: x mandatory;
    scroll-behavior: smooth;
    -webkit-overflow-scrolling: touch;
    /* Edge fade mask */
    mask-image: linear-gradient(to right, transparent, #000 28px, #000 calc(100% - 28px), transparent);
  }
  @media (min-width: 640px) { .rail { grid-auto-columns: 70%; } }
  @media (min-width: 1024px) { .rail { grid-auto-columns: 42%; } }

  .slide {
    scroll-snap-align: center;
    transition:
      transform .35s cubic-bezier(.2,.7,.3,1),
      filter .35s cubic-bezier(.2,.7,.3,1),
      opacity .35s cubic-bezier(.2,.7,.3,1);
    transform-origin: center;
    opacity: .85;
    filter: saturate(.9);
  }
  /* active: gentle scale + glow ring via outline; parallax uses CSS vars */
  .slide.is-active {
    opacity: 1;
    transform: scale(1.03) translateZ(0);
    filter: saturate(1);
  }
  .slide.is-active .card {
    box-shadow:
      0 10px 30px rgba(0,0,0,.35),
      0 0 0 1px rgba(255,255,255,.06),
      0 0 0 2px color-mix(in oklab, var(--aurora-a) 18%, transparent);
  }
  /* Parallax on the screenshot inside the card's first figure */
  .slide.is-active article figure img {
    transition: transform .25s ease;
    transform:
      translate3d(var(--tx, 0px), var(--ty, 0px), 0)
      scale(var(--zoom, 1.04));
    will-change: transform;
  }

  .nav { position: absolute; z-index: 1; top: 50%; transform: translateY(-50%); }
  .nav.prev { left: -6px; }
  .nav.next { right: -6px; }

  .dots { margin-top: .75rem; display: flex; justify-content: center; gap: .5rem; }
  .dot { width: 8px; height: 8px; border-radius: 9999px; background: rgba(255,255,255,.25); transition: transform .2s ease, background .2s ease; }
  .dot.is-active { background: var(--color-accent); transform: scale(1.2); }

  /* Hide scrollbar but keep scrollability */
  .rail::-webkit-scrollbar { display: none; }
  .rail { scrollbar-width: none; }
</style>

<script>
  const root = document.querySelector('[data-showcase]');
  const rail = root.querySelector('#proj-rail');
  const dots = [...root.querySelectorAll('.dot')];
  const prev = root.querySelector('[data-prev]');
  const next = root.querySelector('[data-next]');
  const slides = [...rail.querySelectorAll('.slide')];
  const status = root.querySelector('#sr-status');

  const reduce = matchMedia('(prefers-reduced-motion: reduce)').matches;

  const center = (i) => slides[i]?.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });

  // active detection via IO
  let index = 0;
  const io = new IntersectionObserver((entries) => {
    const visible = entries
      .filter(e => e.isIntersecting)
      .sort((a,b) => b.intersectionRatio - a.intersectionRatio)[0];
    if (!visible) return;
    index = slides.indexOf(visible.target);
    slides.forEach((s, i) => s.classList.toggle('is-active', i === index));
    slides.forEach((s, i) => s.setAttribute('aria-selected', i === index ? 'true' : 'false'));
    dots.forEach((d, i) => d.classList.toggle('is-active', i === index));
    status.textContent = `Slide ${index + 1} of ${slides.length}`;
  }, { root: rail, threshold: 0.6 });
  slides.forEach(s => io.observe(s));

  // arrows
  prev.addEventListener('click', () => { index = Math.max(0, index - 1); center(index); });
  next.addEventListener('click', () => { index = Math.min(slides.length - 1, index + 1); center(index); });

  // dots
  dots.forEach(d => d.addEventListener('click', () => {
    index = Number(d.getAttribute('data-index')) || 0;
    center(index);
  }));

  // drag-to-scroll with click safety
  let isDown = false, startX = 0, startLeft = 0, moved = 0;
  rail.addEventListener('pointerdown', (e) => {
    isDown = true; moved = 0;
    rail.setPointerCapture(e.pointerId);
    startX = e.clientX; startLeft = rail.scrollLeft;
  });
  rail.addEventListener('pointermove', (e) => {
    if (!isDown) return;
    const dx = e.clientX - startX; moved = Math.max(moved, Math.abs(dx));
    rail.scrollLeft = startLeft - dx;
  });
  rail.addEventListener('pointerup', () => { isDown = false; });

  // keyboard
  rail.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowRight') { next.click(); e.preventDefault(); }
    if (e.key === 'ArrowLeft') { prev.click(); e.preventDefault(); }
  });

  // -------- Auto-play (pauses on hover/focus/drag/hidden) --------
  let autoplayTimer = 0;
  const AUTOPLAY_MS = 5000;

  const startAutoplay = () => {
    if (reduce || autoplayTimer) return;
    autoplayTimer = setInterval(() => {
      // advance, wrap at end
      const nextIndex = Math.min(slides.length - 1, index + 1);
      center(nextIndex === index ? 0 : nextIndex);
    }, AUTOPLAY_MS);
  };
  const stopAutoplay = () => { clearInterval(autoplayTimer); autoplayTimer = 0; };

  const pauseReasons = new Set<string>();
  const pause = (reason: string) => { pauseReasons.add(reason); stopAutoplay(); };
  const resume = (reason: string) => {
    pauseReasons.delete(reason);
    if (pauseReasons.size === 0) startAutoplay();
  };

  if (!reduce) {
    startAutoplay();
    root.addEventListener('mouseenter', () => pause('hover'));
    root.addEventListener('mouseleave', () => resume('hover'));
    root.addEventListener('focusin', () => pause('focus'));
    root.addEventListener('focusout', () => resume('focus'));
    rail.addEventListener('pointerdown', () => pause('drag'));
    rail.addEventListener('pointerup',   () => resume('drag'));
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) pause('hidden'); else resume('hidden');
    });
  }

  // -------- Parallax zoom on active slide --------
  // We translate & scale the image inside the active slide using CSS vars.
  let raf = 0;
  const updateParallax = (e) => {
    const active = slides[index];
    if (!active) return;

    const img = active.querySelector('article figure img');
    if (!img) return;

    const rect = active.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;

    const dx = (e.clientX - cx) / (rect.width / 2);   // -1..1
    const dy = (e.clientY - cy) / (rect.height / 2);  // -1..1

    const maxMove = 10; // px
    active.style.setProperty('--tx', `${(-dx * maxMove).toFixed(2)}px`);
    active.style.setProperty('--ty', `${(-dy * maxMove).toFixed(2)}px`);
    active.style.setProperty('--zoom', '1.06');
  };

  const resetParallax = () => {
    const active = slides[index];
    if (!active) return;
    active.style.setProperty('--tx', '0px');
    active.style.setProperty('--ty', '0px');
    active.style.setProperty('--zoom', '1.04');
  };

  if (!reduce) {
    root.addEventListener('pointermove', (e) => {
      cancelAnimationFrame(raf);
      raf = requestAnimationFrame(() => updateParallax(e));
    });
    root.addEventListener('pointerleave', resetParallax);
    window.addEventListener('scroll', () => { cancelAnimationFrame(raf); raf = requestAnimationFrame(resetParallax); }, { passive: true });
  } else {
    // ensure base zoom without motion
    resetParallax();
  }
</script>
